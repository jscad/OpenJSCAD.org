/*
JSCAD Object to AutoCAD DXF Entity Serialization

## License

Copyright (c) 2018 Z3 Development https://github.com/z3dev

All code released under MIT license

Notes:
1) CAG conversion to:
     POLYLINE
     LWPOLYLINE
2) CSG conversion to:
     3DFACE
     POLYLINE (face mesh)
3) Path2D conversion to:
     LWPOLYLINE
TBD
1) support binary output
2) add color conversion, and translation for CSG

*/

const {isCAG, isCSG} = require('@jscad/csg')
const {ensureManifoldness} = require('@jscad/io-utils')
const {dxfHeaders, dxfClasses, dxfTables, dxfBlocks, dxfObjects} = require('./autocad_AC2017')

const mimeType = 'application/dxf'

/** Serialize the give objects to AutoCad DXF format.
 * @param {Object|Array} objects - objects to serialize as DXF
 * @param {Object} [options] - options for serialization
 * @returns {Array} serialized contents, DXF format
 */
const serialize = function (objects, options) {
  const defaults = {
    cagTo: 'lwpolyline', // or polyline
    csgTo: '3dface', // or polyline
    pathTo: 'lwpolyline',
    statusCallback: null
  }
  options = Object.assign({}, defaults, options)

  let dxfContent = `999
DXF generated by JSCAD
${dxfHeaders(options)}
${dxfClasses(options)}
${dxfTables(options)}
${dxfBlocks(options)}
${dxfEntities(objects, options)}
${dxfObjects(options)}
  0
EOF
`
  return [dxfContent]
}

/** Serialize the given objects as a DXF entity section
 * @param {Array} objects - objects to serialize as DXF
 * @param {Object} options - options for serialization
 * @returns {Object} serialized contents, DXF format
 */
const dxfEntities = function (objects, options) {
  objects = toArray(objects)
  let entityContents = objects.map(function (object, i) {
    if (isCAG(object)) {
      let paths = object.getOutlinePaths()
      if (options.cagTo === 'polyline') {
        return PathsToPolyine(paths, options)
      }
      return PathsToLwpolyine(paths, options)
    }
    if (isCSG(object)) {
      object = ensureManifoldness(object)
      if (options.csgTo === 'polyline') {
        return PolygonsToPolyline(object, options)
      }
      return PolygonsTo3DFaces(object, options)
    }
    if (isPath(object)) {
    // mimic a CAG outline path
      let points = object.getPoints()
      let closed = object.isClosed()
      let path = {closed: closed, points: points}
      return PathsToLwpolyine([path], options)
    }
    return ''
  })
  let section = `  0
SECTION
  2
ENTITIES
`
  entityContents.forEach(function (content) {
    if (content) {
      section += content
    }
  })
  section += `  0
ENDSEC`
  return section
}

//
// convert the given paths (from CAG outlines) to DXF lwpolyline entities
// @return array of strings
//
// Group Codes Used:
// 5 - Handle, unique HEX value, e.g. 5C6
// 8 - layer name (0 is default layer)
// 67 (0 - model space, 1 - paper space)
// 100 -
//
const PathsToLwpolyine = function (paths, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  paths.map(function (path, i) {
    if (path.points.length < 1) return
    let numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    str += `  0
LWPOLYLINE
  5
${getEntityId()}
  100
AcDbEntity
  8
0
  67
0
  100
AcDbPolyline
  90
${numpointsClosed}
  70
${(path.closed ? 1 : 0)}
`
    for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      let pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      let point = path.points[pointindexwrapped]
      str += `  10
${point.x}
  20
${point.y}
`
    }
    options.statusCallback && options.statusCallback({progress: 100 * i / paths.length})
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

//
// convert the given paths (from CAG outlines) to DXF polyline (2D line) entities
// @return array of strings
//
const PathsToPolyine = function (paths, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  paths.map(function (path, i) {
    let numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    str += `  0
POLYLINE
  5
${getEntityId()}
  100
AcDbEntity
  8
0
  100
AcDb2dPolyline
`
    for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      let pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      let point = path.points[pointindexwrapped]
      str += `  0
VERTEX
  5
${getEntityId()}
  100
AcDbEntity
  8
0
  100
AcDbVertex
  100
AcDb2dVertex
 10
${point.x}
 20
${point.y}
`
    }
    str += `  0
SEQEND
  5
${getEntityId()}
  100
AcDbEntity
`
    options.statusCallback && options.statusCallback({progress: 100 * i / paths.length})
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

//
// convert the given CSG to DXF 3D face entities
// @return array of strings
//
const PolygonsTo3DFaces = function (csg, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  csg.polygons.map(function (polygon, i) {
    let triangles = polygonToTriangles(polygon)
    triangles.map(function (triangle, i) {
      str += triangleTo3DFaces(triangle, options)
    })
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

//
// convert the given polygon to triangles
//
// NOTE: This only works for CONVEX polygons
const polygonToTriangles = (polygon) => {
  let length = polygon.vertices.length - 2
  if (length < 1) return []

  let pivot = polygon.vertices[0]
  let triangles = []
  for (let i = 0; i < length; i++) {
    triangles.push([pivot, polygon.vertices[i + 1], polygon.vertices[i + 2]])
  }
  return triangles
}

//
// convert the given triangle to DXF 3D face entity
//
const triangleTo3DFaces = (triangle, options) => {
  let corner10 = triangle[0].pos
  let corner11 = triangle[1].pos
  let corner12 = triangle[2].pos
  let corner13 = triangle[2].pos // same in DXF
  let str = `  0
3DFACE
  5
${getEntityId()}
  100
AcDbEntity
  8
0
  100
AcDbFace
  70
0
  10
${corner10.x}
  20
${corner10.y}
  30
${corner10.z}
  11
${corner11.x}
  21
${corner11.y}
  31
${corner11.z}
  12
${corner12.x}
  22
${corner12.y}
  32
${corner12.z}
  13
${corner13.x}
  23
${corner13.y}
  33
${corner13.z}
`
  return str
}

// convert the given CSG to DXF POLYLINE (polyface mesh)
// FIXME The entity types are wrong, resulting in imterpretation as a 3D lines, not faces
// @return array of strings
const PolygonsToPolyline = function (csg, options) {
  options.statusCallback && options.statusCallback({progress: 100})
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  let mesh = polygons2polyfaces(csg.polygons)
  if (mesh.faces.length > 0) {
    str += `  0
POLYLINE
  5
${getEntityId()}
  100
AcDbEntity
  8
0
  100
AcDb3dPolyline
  70
64
  71
${mesh.vertices.length}
  72
${mesh.faces.length}
`
    mesh.vertices.forEach(function (vertex) {
      str += `  0
VERTEX
  5
${getEntityId()}
  100
AcDbEntity
  8
0
  100
AcDbVertex
  100
AcDb3dPolylineVertex
  10
${vertex[0]}
  20
${vertex[1]}
  30
${vertex[2]}
  70
192
`
    })
    mesh.faces.forEach(function (face) {
      str += `  0
VERTEX
  5
${getEntityId()}
  100
AcDbEntity
  8
0
  100
AcDbVertex
  100
AcDb3dPolylineVertex
  10
0
  20
0
  30
0
  70
128
  71
${face[0]}
  72
${face[1]}
  73
${face[2]}
  74
${face[3]}
`
    })
  }
  return [str]
}

// convert the given polygons (CSG) to polyfaces (DXF)
// @return array of faces, array of vertices
const polygons2polyfaces = function (polygons) {
  var faces = []
  var vertices = []
  for (var i = 0; i < polygons.length; ++i) {
    let polygon = polygons[i]
    var face = []
    for (var j = 0; j < polygon.vertices.length; ++j) {
      var vv = polygon.vertices[j].pos
      vertices.push([vv.x, vv.y, vv.z])
      face.push(vertices.length)
    }
    while (face.length < 4) { face.push(0) }
    faces.push(face)
  }
  return {faces: faces, vertices: vertices}
}

// get a unique id for a DXF entity
// @return unique id string
var entityId = 0

function getEntityId () {
  entityId++
  // add more zeros if the id needs to be larger
  let padded = '00000' + entityId.toString(16).toUpperCase()
  return 'CAD' + padded.substr(padded.length - 5)
}

// convert the given data to array if not already
// @return array of data
function toArray (data) {
  if (Array.isArray(data)) return data
  return [data]
}

// determin if the given object is a Path2D object
// NOTE: Can be removed once CSG provides this functionality
// @return true or false
function isPath (object) {
  if (object && 'points' in object && Array.isArray(object.points)) {
    return true
  }
  return false
}

module.exports = {
  serialize,
  mimeType
}
