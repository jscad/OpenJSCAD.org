/*
JSCAD Object to SVG Format Serialization

## License

Copyright (c) 2018 JSCAD Organization https://github.com/jscad

All code released under MIT license

Notes:
1) geom2 conversion to:
     SVG GROUP containing a SVG PATH for each outline of the geometry
2) geom3 conversion to:
     none
3) path2 conversion to:
     SVG GROUP containing a SVG PATH for each path
*/

const { color, geometry, math, measurements, utils } = require('@jscad/modeling')

const stringify = require('onml/lib/stringify')

const mimeType = 'image/svg+xml'

/** Serialize the give objects to SVG format.
 * @param {Object} [options] - options for serialization
 * @param {Object|Array} objects - objects to serialize as SVG
 * @returns {Array} serialized contents, SVG format
 */
const serialize = (options, ...objects) => {
  const defaults = {
    unit: 'mm', // em | ex | px | in | cm | mm | pt | pc
    decimals: 10000,
    statusCallback: null
  }
  options = Object.assign({}, defaults, options)

  objects = utils.flatten(objects)

  // convert only 2D geometries
  let objects2d = objects.filter((object) => geometry.geom2.isA(object) || geometry.path2.isA(object))

  if (objects2d.length === 0) throw new Error('only 2D geometries can be serialized to SVG')
  if (objects.length !== objects2d.length) console.warn('some objects could not be serialized to SVG')

  options.statusCallback && options.statusCallback({progress: 0})

  // get the lower and upper bounds of ALL convertable objects
  let bounds = getBounds(objects2d)

  let width = 0
  let height = 0
  if (bounds) {
    width = Math.round((bounds[1][0] - bounds[0][0]) * options.decimals) / options.decimals
    height = Math.round((bounds[1][1] - bounds[0][1]) * options.decimals) / options.decimals
  }

  let body = ['svg',
    {
      width: width + options.unit,
      height: height + options.unit,
      viewBox: ('0 0 ' + width + ' ' + height),
      version: '1.1',
      baseProfile: 'tiny',
      xmlns: 'http://www.w3.org/2000/svg',
      'xmlns:xlink': 'http://www.w3.org/1999/xlink'
    }
  ]
  if (bounds) {
    body = body.concat(convertObjects(objects2d, bounds, options))
  }

  let svg = `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by OpenJSCAD.org -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">
${stringify(body)}`

  options.statusCallback && options.statusCallback({progress: 100})
  return [svg]
}

/*
 * Measure the bounds of the given objects, which is required to offset all points to positive X/Y values.
 */
const getBounds = (objects) => {
  let allbounds = measurements.measureBounds(objects)

  if (objects.length === 1) return allbounds

  // create a sum of the bounds
  let sumofbounds = allbounds.reduce((sum, bounds) => {
    math.vec3.min(sum[0], sum[0], bounds[0])
    math.vec3.max(sum[1], sum[1], bounds[1])
    return sum
  }, [[0, 0, 0], [0, 0, 0]])
  return sumofbounds
}

const convertObjects = (objects, bounds, options) => {
  let xoffset = 0 - bounds[0][0]
  let yoffset = 0 - bounds[0][1]

  let contents = []
  objects.forEach((object, i) => {
    options.statusCallback && options.statusCallback({progress: 100 * i / objects.length})

    if (geometry.geom2.isA(object)) {
      contents.push(convertGeom2(object, [xoffset, yoffset], options))
    }
    if (geometry.path2.isA(object)) {
      contents.push(convertPaths([object], [xoffset, yoffset], options))
    }
  })
  return contents
}

const convertGeom2 = (object, offsets, options) => {
  let outlines = geometry.geom2.toOutlines(object)
  let paths = outlines.map((outline) => geometry.path2.fromPoints({closed: true}, outline))
  if (object.color) {
    paths.forEach((path) => {
      path.fill = object.color
    })
  }
  return convertToContinousPath(paths, offsets, options)
}

const convertToContinousPath = (paths, offset, options) => {
  let instructions = ''
  paths.forEach((path) => instructions += convertPath(path, offset, options))
  let continouspath = ['path', {d: instructions}]
  if (paths.length > 0) {
    let path0 = paths[0]
    if (path0.fill) {
      continouspath = ['path', {'fill-rule': 'evenodd', fill: convertColor(path0.fill), d: instructions}]
    }
  }
  return ['g', continouspath]
}

const convertPaths = (paths, offsets, options) => {
  return paths.reduce((res, path, i) => {
    if (path.color) {
      return res.concat([['path', {stroke: convertColor(path.color), 'stroke-width': 1, d: convertPath(path, offsets, options)}]])
    }
    return res.concat([['path', {d: convertPath(path, offsets, options)}]])
  }, ['g'])
}

const convertPath = (path, offsets, options) => {
  let str = ''
  let numpointsClosed = path.points.length + (path.isClosed ? 1 : 0)
  for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
    let pointindexwrapped = pointindex
    if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
    let point = path.points[pointindexwrapped]
    let x = Math.round((point[0] + offsets[0]) * options.decimals) / options.decimals
    let y = Math.round((point[1] + offsets[1]) * options.decimals) / options.decimals
    if (pointindex > 0) {
      str += `L${x} ${y}`
    } else {
      str += `M${x} ${y}`
    }
  }
  return str
}

const convertColor = (color) => {
  return `rgb(${color[0] * 255},${color[1] * 255},${color[2] * 255},${color[3] * 255})`
}

module.exports = {
  serialize,
  mimeType
}
