/*
JSCAD Object to SVG Format Serialization

## License

Copyright (c) 2018 JSCAD Organization https://github.com/jscad

All code released under MIT license

Notes:
1) geom2 conversion to:
     SVG GROUP containing a SVG PATH for each outline of the geometry
2) geom3 conversion to:
     none
3) Path2D conversion to:
     SVG GROUP containing a SVG PATH for each path
*/

const { geometry, math, measurements } = require('@jscad/csg')

const stringify = require('onml/lib/stringify')

const mimeType = 'image/svg+xml'

/** Serialize the give objects to SVG format.
 * @param {Object} [options] - options for serialization
 * @param {Object|Array} objects - objects to serialize as SVG
 * @returns {Array} serialized contents, SVG format
 */
const serialize = (options, ...objects) => {
  const defaults = {
    unit: 'mm', // em | ex | px | in | cm | mm | pt | pc
    decimals: 10000,
    statusCallback: null
  }
  options = Object.assign({}, defaults, options)

  // TODO flatten
  // objects = toArray(objects)

  // console.log('params', params)
  // console.log('options', options)
  // console.log('objects', objects)

  options.statusCallback && options.statusCallback({progress: 0})

  // get the lower and upper bounds of ALL convertable objects
  var bounds = getBounds(objects)

  var width = 0
  var height = 0
  if (bounds) {
    width = Math.round((bounds[1][0] - bounds[0][0]) * options.decimals) / options.decimals
    height = Math.round((bounds[1][1] - bounds[0][1]) * options.decimals) / options.decimals
  }

  var body = ['svg',
    {
      width: width + options.unit,
      height: height + options.unit,
      viewBox: ('0 0 ' + width + ' ' + height),
      version: '1.1',
      baseProfile: 'tiny',
      xmlns: 'http://www.w3.org/2000/svg',
      'xmlns:xlink': 'http://www.w3.org/1999/xlink'
    }
  ]
  if (bounds) {
    body = body.concat(convertObjects(objects, bounds, options))
  }

  var svg = `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by OpenJSCAD.org -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">
${stringify(body)}`

  options.statusCallback && options.statusCallback({progress: 100})
  return [svg]
}

const getBounds = (objects) => {
  let allbounds = measurements.measureBounds(objects)

  if (objects.length === 1) return allbounds

  // create a sum of the bounds
  let sumofbounds = allbounds.reduce((sum, bounds) => {
    math.vec3.min(sum[0], sum[0], bounds[0])
    math.vec3.max(sum[1], sum[1], bounds[1])
    return sum
  }, [[0, 0, 0], [0, 0, 0]])
  return sumofbounds
}

const convertObjects = (objects, bounds, options) => {
  var xoffset = 0 - bounds[0][0]
  var yoffset = 0 - bounds[0][1]

  let contents = []
  objects.forEach((object, i) => {
    options.statusCallback && options.statusCallback({progress: 100 * i / objects.length})

    if (geometry.geom2.isA(object)) {
      contents.push(convertGeom2(object, [xoffset, yoffset], options))
    }
    if (geometry.path2.isA(object)) {
      contents.push(convertPaths([object], [xoffset, yoffset], options))
    }
  })
  return contents
}

const convertGeom2 = (object, offsets, options) => {
  let outlines = geometry.geom2.toOutlines(object)
  // TODO set oddeven, and correct order of points
  let paths = outlines.map((outline) => geometry.path2.fromPoints({closed: true}, outline))
  return convertPaths(paths, offsets, options)
}

const convertPaths = (paths, offsets, options) => {
  return paths.reduce((res, path, i) => {
    return res.concat([['path', {d: convertPath(path, offsets, options)}]])
  }, ['g'])
}

const convertPath = (path, offsets, options) => {
  var str = ''
  var numpointsClosed = path.points.length + (path.isClosed ? 1 : 0)
  for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
    var pointindexwrapped = pointindex
    if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
    var point = path.points[pointindexwrapped]
    let x = Math.round((point[0] + offsets[0]) * options.decimals) / options.decimals
    let y = Math.round((point[1] + offsets[1]) * options.decimals) / options.decimals
    if (pointindex > 0) {
      str += `L${x} ${y}`
    } else {
      str += `M${x} ${y}`
    }
  }
  return str
}

module.exports = {
  serialize,
  mimeType
}
